use std::collections::VecDeque;
use std::io::{self, prelude::*};

// io template from CountZero
trait TokenStream<T> {
    fn token(&mut self) -> T;
}

struct FastInput<R> {
    stdin: R,
    pos: usize,
}

impl<R: BufRead> From<R> for FastInput<R> {
    fn from(r: R) -> Self {
        FastInput { stdin: r, pos: 0 }
    }
}

impl<R: BufRead> TokenStream<u8> for FastInput<R> {
    fn token(&mut self) -> u8 {
        loop {
            if let Ok(buf) = self.stdin.fill_buf() {
                while self.pos < buf.len() {
                    self.pos += 1;
                    if buf[self.pos - 1] > 32 {
                        return buf[self.pos - 1];
                    }
                }
                if self.pos == 0 {
                    return 0;
                }
            } else {
                return 0;
            }
            self.stdin.consume(self.pos);
            self.pos = 0;
        }
    }
}

impl<R: BufRead> TokenStream<Vec<u8>> for FastInput<R> {
    fn token(&mut self) -> Vec<u8> {
        let mut ans = Vec::new();
        let mut parse_token = false;
        loop {
            if let Ok(buf) = self.stdin.fill_buf() {
                if !parse_token {
                    while self.pos < buf.len() && buf[self.pos] <= 32 {
                        self.pos += 1;
                    }
                }
                while self.pos < buf.len() && buf[self.pos] > 32 {
                    parse_token = true;
                    ans.push(buf[self.pos]);
                    self.pos += 1;
                }
                if self.pos != buf.len() || self.pos == 0 {
                    return ans;
                }
            }
            self.stdin.consume(self.pos);
            self.pos = 0;
        }
    }
}

macro_rules! impl_token_stream {
    ($($t:ident),+) => {$(
        impl<R: BufRead> TokenStream<$t> for FastInput<R> {
           fn token(&mut self) -> $t {
                let mut ans = 0;
                let mut parse_token = false;
                loop {
                    if let Ok(buf) = self.stdin.fill_buf() {
                        if !parse_token {
                            while self.pos < buf.len() && buf[self.pos] <= 32 {
                                self.pos += 1;
                            }
                        }
                        while self.pos < buf.len() && buf[self.pos] > 32 {
                            parse_token = true;
                            ans = ans * 10 + (buf[self.pos] - b'0') as $t;
                            self.pos += 1;
                        }
                        if self.pos != buf.len() || self.pos == 0 {
                            return ans;
                        }
                    }
                    self.stdin.consume(self.pos);
                    self.pos = 0;
                }
           }
        }
    )+}
}

impl_token_stream!(usize);
// end io template

type Pos = (usize, usize);

#[derive(Debug, PartialEq, Eq)]
struct Grid(Vec<Vec<u8>>, usize, usize);

const ADJACENT: [(i32, i32); 4] = [(-1, 0), (0, -1), (1, 0), (0, 1)];
const ADJACENT_DIAG: [(i32, i32); 8] = [
    (-1, -1),
    (-1, 0),
    (-1, 1),
    (0, -1),
    (0, 1),
    (1, -1),
    (1, 0),
    (1, 1),
];

impl Grid {
    fn rows(&self) -> usize {
        self.1
    }
    fn cols(&self) -> usize {
        self.2
    }
    fn is_island(&self, (i, j): Pos) -> bool {
        self.0[i][j] == b'#'
    }
    fn is_border(&self, (i, j): Pos) -> bool {
        i == 0 || i == self.rows() - 1 || j == 0 || j == self.cols() - 1
    }
    fn is_valid(&self, (i, j): (i32, i32)) -> bool {
        i >= 0 && j >= 0 && i < self.rows() as i32 && j < self.cols() as i32
    }

    fn has_round_trip(&self, pos: Pos, safety: usize, rt: &mut RoundTrip) -> bool {
        // Find all reachable cells from `pos`,
        // dfs over initial position, which forms the path
        let mut q = VecDeque::new();
        q.push_back(pos);
        while let Some(pos @ (i, j)) = q.pop_front() {
            if rt.path[i][j] || rt.dist[i][j] < safety || self.is_island(pos) {
                continue;
            }

            rt.path[i][j] = true;

            for (delta_i, delta_j) in ADJACENT {
                let (i, j) = (i as i32 + delta_i, j as i32 + delta_j);
                if self.is_valid((i, j)) {
                    q.push_back((i as usize, j as usize));
                }
            }
        }

        // Start from any island.
        // Visit all cells and stop at the path.
        // If we can reach a border without
        // encountering a path, then there isn't a roundtrip, by definition
        // (some path p fully encircles the island if it is impossible to go
        // from an island cell to a cell on the grid border);
        q.push_back(rt.island);
        while let Some(pos @ (i, j)) = q.pop_front() {
            if rt.path[i][j] || rt.visited[i][j] {
                continue;
            }

            if self.is_border(pos) {
                return false;
            }

            rt.visited[i][j] = true;

            // By definition we can take a diagonal path
            for (delta_i, delta_j) in ADJACENT_DIAG {
                let (i, j) = (i as i32 + delta_i, j as i32 + delta_j);
                if self.is_valid((i, j)) {
                    q.push_back((i as usize, j as usize));
                }
            }
        }

        true
    }
}

struct RoundTrip<'a> {
    path: Vec<Vec<bool>>,
    visited: Vec<Vec<bool>>,
    island: Pos,
    dist: &'a [Vec<usize>],
}

impl RoundTrip<'_> {
    // avoid reallocations
    pub fn reset(&mut self) {
        for line in self.visited.iter_mut() {
            for elem in line.iter_mut() {
                *elem = false;
            }
        }
        for line in self.path.iter_mut() {
            for elem in line.iter_mut() {
                *elem = false;
            }
        }
    }
}

#[derive(Debug, PartialEq, Eq)]
struct Problem {
    grid: Grid,
    queries: Vec<Pos>,
}

impl Problem {
    pub fn solve(&self) -> String {
        if self.queries.is_empty() {
            return String::new();
        }

        let mut dist = vec![vec![usize::MAX; self.grid.cols()]; self.grid.rows()];

        let mut flood_fill = VecDeque::new();
        let mut island = (0, 0);

        for i in 0..self.grid.rows() {
            for j in 0..self.grid.cols() {
                match self.grid.0[i][j] {
                    b'v' => {
                        dist[i][j] = 0;
                        flood_fill.push_back((i, j));
                    }
                    b'#' => island = (i, j),
                    _ => (),
                }
            }
        }

        // Flood fill, finding for each cell its safety
        while let Some((i, j)) = flood_fill.pop_front() {
            for (delta_i, delta_j) in ADJACENT {
                let (adj_i, adj_j) = (i as i32 + delta_i, j as i32 + delta_j);
                if !self.grid.is_valid((adj_i, adj_j)) {
                    continue;
                }

                let (adj_i, adj_j) = (adj_i as usize, adj_j as usize);
                if dist[i][j] + 1 < dist[adj_i][adj_j] {
                    dist[adj_i][adj_j] = dist[i][j] + 1;
                    flood_fill.push_back((adj_i, adj_j));
                }
            }
        }

        let mut rt = RoundTrip {
            path: vec![vec![false; self.grid.cols()]; self.grid.rows()],
            visited: vec![vec![false; self.grid.cols()]; self.grid.rows()],
            island,
            dist: &dist,
        };

        let mut out = String::new();
        for &query in &self.queries {
            let query = (query.0 - 1, query.1 - 1);
            // Binary search different safety values
            let mut left = 0;
            let mut right = self.grid.rows() + self.grid.cols();

            while left + 1 < right {
                let mid = left + ((right - left) / 2);

                if self.grid.has_round_trip(query, mid, &mut rt) {
                    left = mid;
                } else {
                    right = mid;
                }
                rt.reset();
            }

            out.push_str(&left.to_string());
            out.push('\n');
        }

        out
    }
}

fn parse<R: BufRead>(mut r: FastInput<R>) -> Problem {
    let rows = r.token();
    let cols = r.token();
    let q = r.token();

    let mut grid = Vec::with_capacity(rows);
    for _ in 0..rows {
        let line: Vec<u8> = r.token();
        grid.push(line);
    }
    let grid = Grid(grid, rows, cols);

    let mut queries = Vec::with_capacity(q);
    for _ in 0..q {
        queries.push((r.token(), r.token()))
    }

    Problem { grid, queries }
}

fn main() {
    let stdin = io::stdin();
    let reader = FastInput::from(stdin.lock());
    println!("{}", parse(reader).solve());
}

mod tests {
    use super::*;

    fn expect(input: &str, expect: &str) {
        assert_eq!(parse(FastInput::from(input.as_bytes())).solve(), expect);
    }

    #[test]
    fn example() {
        expect(
            "9 9 3
.........
.........
....###..
...v#....
..###....
...##...v
...##....
.........
v........
1 1
9 1
5 7
",
            "3
0
3
",
        )
    }

    #[test]
    fn small() {
        expect(
            "3 3 5
..v
.#.
...
1 2
1 3
2 3
2 1
3 2
",
            "0
0
0
0
0
",
        )
    }

    #[test]
    fn big() {
        expect(
            "14 13 5
.............
.............
.............
...vvvvvvv...
...v.....v...
...v.###.v...
...v.#.#.v...
...v..v..v...
...v..v..v...
....v...v....
.....vvv.....
.............
.............
.............
1 1
7 7
5 6
4 10
13 6
",
            "3
0
1
0
2
",
        )
    }

    #[test]
    fn maze() {
        expect(
            "10 11 4
...........
..#######..
..#..#..#..
..#.....#..
..#..v..#..
..#.###.#..
..#.#.#.#..
..#...#.#..
..#####.#..
...........
7 6
3 7
6 8
1 1
",
            "1
2
3
4
",
        )
    }

    #[test]
    fn hundred() {
        expect(
            "100 100 4
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
............................................................v.......................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
............................................................................................v.......
....................................................................................................
...................v................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................######..........................................
....................................................#...............................................
................................................#####...............................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
.................................................................................v..................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
................................................v...................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
....................................................................................................
7 6
3 7
6 8
99 99
",
            "19
19
19
19
",
        )
    }

    #[test]
    fn blocker() {
        expect(
            "8 8 1
v.......
........
........
........
........
........
......#.
........
8 8
",
            "10
",
        )
    }
}
